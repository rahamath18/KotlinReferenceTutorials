<?xml version="1.0" encoding="utf-8"?>
<resources>

    <string name="labelFunctionsandLambdas"> 5. Functions and Lambdas</string>

    <string name="labelFunctions">5.1 Functions</string>
    <string name="labelLambdas">5.2 Lambdas</string>
    <string name="labelInlineFunctions">5.3 Inline Functions</string>
    <string name="labelCoroutines">5.4 Coroutines</string>

    <string name="topicFunctionsandLambdas">
         <![CDATA[

            Functions and Lambdas

         </p>
         ]]>
     </string>

    <string name="topicContentFunctions">
        <![CDATA[

                <h1 id="functions">
                Functions
            </h1>
            <h2 id="function-declarations">
                Function Declarations
            </h2>
            <p>
                Functions in Kotlin are declared using the fun keyword
            </p>
            <pre><code>fun double(x: Int): Int {
                return 2*x
            }
            </code></pre>
            <h2 id="function-usage">Function Usage</h2>
            <p>
                Calling functions uses the traditional approach
            </p>
            <pre><code>val result = double(2)
            </code></pre>
            <p>
                Calling member functions uses the dot notation
            </p>
            <pre><code>Sample().foo() // create instance of class Sample and call foo
            </code></pre>
            <h3 id="infix-notation">Infix notation</h3>
            <p>
                Functions can also be called using infix notations when
            </p>
            <ul>
                <li>
                    They are member functions or
                    <a href="https://kotlinlang.org/docs/reference/extensions.html">
                        extension functions
                    </a>
                </li>
                <li>
                    They have a single parameter
                </li>
                <li>
                    They are marked with the <code>infix</code> keyword
                </li>
            </ul>
            <pre><code>// Define extension to Int
            infix fun Int.shl(x: Int): Int {
            ...
            }

            // call extension function using infix notation

            1 shl 2

            // is the same as

            1.shl(2)
            </code></pre>
            <h3 id="parameters">Parameters</h3>
            <p>
            Function parameters are defined using Pascal notation, i.e. <em>name</em>:    <em>type</em>. Parameters are separated using commas. Each parameter must
                be explicitly typed.
            </p>
            <pre><code>fun powerOf(number: Int, exponent: Int) {
            ...
            }
            </code></pre>
            <h3 id="default-arguments">Default Arguments</h3>
            <p>
                Function parameters can have default values, which are used when a
                corresponding argument is omitted. This allows for a reduced number of
                overloads compared to other languages.
            </p>
            <pre><code>fun read(b: Array&lt;Byte&gt;, off: Int = 0, len: Int = b.size) {
            ...
            }
            </code></pre>
            <p>
                Default values are defined using the = after type along with the value.
            </p>
            <p>
                Overriding methods always use the same default parameter values as the base
                method. When overriding a method with default parameters values, the
                default parameter values must be omitted from the signature:
            </p>
            <pre><code>open class A {
                open fun foo(i: Int = 10) { ... }
            }

            class B : A() {
                override fun foo(i: Int) { ... }  // no default value allowed
            }
            </code></pre>
            <h3 id="named-arguments">Named Arguments</h3>
            <p>
                Function parameters can be named when calling functions. This is very
                convenient when a function has a high number of parameters or default ones.
            </p>
            <p>
                Given the following function
            </p>
            <pre><code>fun reformat(str: String,
                         normalizeCase: Boolean = true,
                         upperCaseFirstLetter: Boolean = true,
                         divideByCamelHumps: Boolean = false,
                         wordSeparator: Char = \' \') {
            ...
            }
            </code></pre>
            <p>
                we could call this using default arguments
            </p>
            <pre><code>reformat(str)
            </code></pre>
            <p>
                However, when calling it with non-default, the call would look something
                like
            </p>
            <pre><code>reformat(str, true, true, false, \'_\')
            </code></pre>
            <p>
                With named arguments we can make the code much more readable
            </p>
            <pre><code>reformat(str,
                normalizeCase = true,
                upperCaseFirstLetter = true,
                divideByCamelHumps = false,
                wordSeparator = \'_\'
            )
            </code></pre>
            <p>
                and if we do not need all arguments
            </p>
            <pre><code>reformat(str, wordSeparator = \'_\')
            </code></pre>
            <p>
                Note that the named argument syntax cannot be used when calling Java
                functions, because Java bytecode does not always preserve names of function
                parameters.
            </p>
            <h3 id="unit-returning-functions">Unit-returning functions</h3>
            <p>
            If a function does not return any useful value, its return type is<code>Unit</code>. <code>Unit</code> is a type with only one value -    <code>Unit</code>. This value does not have to be returned explicitly
            </p>
            <pre><code>fun printHello(name: String?): Unit {
                if (name != null)
                    println("Hello ${name}")
                else
                    println("Hi there!")
                // `return Unit` or `return` is optional
            }
            </code></pre>
            <p>
                The <code>Unit</code> return type declaration is also optional. The above
                code is equivalent to
            </p>
            <pre><code>fun printHello(name: String?) {
                ...
            }
            </code></pre>
            <h3 id="single-expression-functions">Single-Expression functions</h3>
            <p>
                When a function returns a single expression, the curly braces can be
                omitted and the body is specified after a = symbol
            </p>
            <pre><code>fun double(x: Int): Int = x * 2
            </code></pre>
            <p>
                Explicitly declaring the return type is
                <a href="https://kotlinlang.org/docs/reference/functions.html#explicit-return-types">
                    optional
                </a>
                when this can be inferred by the compiler
            </p>
            <pre><code>fun double(x: Int) = x * 2
            </code></pre>
            <h3 id="explicit-return-types">Explicit return types</h3>
            <p>
                Functions with block body must always specify return types explicitly,
                unless it\'s intended for them to return <code>Unit</code>,
                <a
                    href="https://kotlinlang.org/docs/reference/functions.html#unit-returning-functions"
                >
                    in which case it is optional
                </a>
                . Kotlin does not infer return types for functions with block bodies
                because such functions may have complex control flow in the body, and the
                return type will be non-obvious to the reader (and sometimes even for the
                compiler).
            </p>
            <h3 id="variable-number-of-arguments-varargs">
                Variable number of arguments (Varargs)
            </h3>
            <p>
            A parameter of a function (normally the last one) may be marked with    <code>vararg</code> modifier:
            </p>
            <pre><code>fun &lt;T&gt; asList(vararg ts: T): List&lt;T&gt; {
                val result = ArrayList&lt;T&gt;()
                for (t in ts) // ts is an Array
                    result.add(t)
                return result
            }
            </code></pre>
            <p>
                allowing a variable number of arguments to be passed to the function:
            </p>
            <pre><code>val list = asList(1, 2, 3)
            </code></pre>
            <p>
                Inside a function a <code>vararg</code>-parameter of type <code>T</code> is
                visible as an array of <code>T</code>, i.e. the <code>ts</code> variable in
                the example above has type <code>Array&lt;out T&gt;</code>.
            </p>
            <p>
            Only one parameter may be marked as <code>vararg</code>. If a    <code>vararg</code> parameter is not the last one in the list, values for
                the following parameters can be passed using the named argument syntax, or,
                if the parameter has a function type, by passing a lambda outside
                parentheses.
            </p>
            <p>
                When we call a <code>vararg</code>-function, we can pass arguments
                one-by-one, e.g. <code>asList(1, 2, 3)</code>, or, if we already have an
                array and want to pass its contents to the function, we use the spread
                operator (prefix the array with <code>*</code>):
            </p>
            <pre><code>val a = arrayOf(1, 2, 3)
            val list = asList(-1, 0, *a, 4)
            </code></pre>
            <h2 id="function-scope">
                Function Scope
                <a
                    href="https://kotlinlang.org/docs/reference/functions.html#function-scope"
                >
                </a>
            </h2>
            <p>
                In Kotlin functions can be declared at top level in a file, meaning you do
                not need to create a class to hold a function, like languages such as Java,
                C# or Scala. In addition to top level functions, Kotlin functions can also
                be declared local, as member functions and extension functions.
            </p>
            <h3 id="local-functions">
                Local Functions
                <a
                    href="https://kotlinlang.org/docs/reference/functions.html#local-functions"
                >
                </a>
            </h3>
            <p>
                Kotlin supports local functions, i.e. a function inside another function
            </p>
            <pre><code>fun dfs(graph: Graph) {
                fun dfs(current: Vertex, visited: Set&lt;Vertex&gt;) {
                    if (!visited.add(current)) return
                    for (v in current.neighbors)
                        dfs(v, visited)
                }

                dfs(graph.vertices[0], HashSet())
            }
            </code></pre>
            <p>
                Local function can access local variables of outer functions (i.e. the
                closure), so in the case above, the <em>visited</em>can be a local variable
            </p>
            <pre><code>fun dfs(graph: Graph) {
                val visited = HashSet&lt;Vertex&gt;()
                fun dfs(current: Vertex) {
                    if (!visited.add(current)) return
                    for (v in current.neighbors)
                        dfs(v)
                }

                dfs(graph.vertices[0])
            }
            </code></pre>
            <h3 id="member-functions">
                Member Functions
                <a
                    href="https://kotlinlang.org/docs/reference/functions.html#member-functions"
                >
                </a>
            </h3>
            <p>
                A member function is a function that is defined inside a class or object
            </p>
            <pre><code>class Sample() {
                fun foo() { print("Foo") }
            }
            </code></pre>
            <p>
                Member functions are called with dot notation
            </p>
            <pre><code>Sample().foo() // creates instance of class Sample and calls foo
            </code></pre>
            <p>
            For more information on classes and overriding members see    <a href="https://kotlinlang.org/docs/reference/classes.html">Classes</a>
                and
                <a href="https://kotlinlang.org/docs/reference/classes.html#inheritance">
                    Inheritance
                </a>
            </p>
            <h2 id="generic-functions">
                Generic Functions
                <a
                    href="https://kotlinlang.org/docs/reference/functions.html#generic-functions"
                >
                </a>
            </h2>
            <p>
                Functions can have generic parameters which are specified using angle
                brackets before the function name
            </p>
            <pre><code>fun &lt;T&gt; singletonList(item: T): List&lt;T&gt; {
                // ...
            }
            </code></pre>
            <p>
            For more information on generic functions see    <a href="https://kotlinlang.org/docs/reference/generics.html">Generics</a>
            </p>
            <h2 id="inline-functions">
                Inline Functions
                <a
                    href="https://kotlinlang.org/docs/reference/functions.html#inline-functions"
                >
                </a>
            </h2>
            <p>
                Inline functions are explained
                <a href="https://kotlinlang.org/docs/reference/inline-functions.html">
                    here
                </a>
            </p>
            <h2 id="extension-functions">
                Extension Functions
            </h2>
            <p>
                Extension functions are explained in
                <a href="https://kotlinlang.org/docs/reference/extensions.html">
                    their own section
                </a>
            </p>
            <h2 id="higher-order-functions-and-lambdas">
                Higher-Order Functions and Lambdas
            </h2>
            <p>
                Higher-Order functions and Lambdas are explained in
                <a href="https://kotlinlang.org/docs/reference/lambdas.html">
                    their own section
                </a>
            </p>
            <h2 id="tail-recursive-functions">
                Tail recursive functions
            </h2>
            <p>
            Kotlin supports a style of functional programming known as    <a href="https://en.wikipedia.org/wiki/Tail_call">tail recursion</a>. This
                allows some algorithms that would normally be written using loops to
                instead be written using a recursive function, but without the risk of
                stack overflow. When a function is marked with the <code>tailrec</code>
                modifier and meets the required form, the compiler optimises out the
                recursion, leaving behind a fast and efficient loop based version instead.
            </p>
            <pre><code>tailrec fun findFixPoint(x: Double = 1.0): Double
                    = if (x == Math.cos(x)) x else findFixPoint(Math.cos(x))
            </code></pre>
            <p>
                This code calculates the fixpoint of cosine, which is a mathematical
                constant. It simply calls Math.cos repeatedly starting at 1.0 until the
                result doesn\'t change any more, yielding a result of 0.7390851332151607.
                The resulting code is equivalent to this more traditional style:
            </p>
            <pre><code>
            private fun findFixPoint(): Double {
                var x = 1.0
                while (true) {
                    val y = Math.cos(x)
                    if (x == y) return y
                    x = y
                }
            }
            </code></pre>
            <p>
                To be eligible for the <code>tailrec</code> modifier, a function must call
                itself as the last operation it performs. You cannot use tail recursion
                when there is more code after the recursive call, and you cannot use it
                within try/catch/finally blocks. Currently tail recursion is only supported
                in the JVM backend.
            </p>


        ]]>
    </string>


    <string name="topicContentLambdas">
		<![CDATA[

 			<h1 id="higher-order-functions-and-lambdas">
				Higher-Order Functions and Lambdas
			</h1>
			<h2 id="higher-order-functions">
				Higher-Order Functions
			</h2>
			<p>
				A higher-order function is a function that takes functions as parameters,
			or returns a function. A good example of such a function is    <code>lock()</code> that takes a lock object and a function, acquires the
				lock, runs the function and releases the lock:
			</p>
			<pre><code>fun &lt;T&gt; lock(lock: Lock, body: () -&gt; T): T {
				lock.lock()
				try {
					return body()
				}
				finally {
					lock.unlock()
				}
			}
			</code></pre>
			<p>
				Let\'s examine the code above: <code>body</code> has a
				<a href="https://kotlinlang.org/docs/reference/lambdas.html#function-types">
					function type
				</a>
				: <code>() -&gt; T</code>, so it\'s supposed to be a function that takes no
				parameters and returns a value of type <code>T</code>. It is invoked inside
				the try-block, while protected by the <code>lock</code>, and its result is
				returned by the <code>lock()</code> function.
			</p>
			<p>
				If we want to call <code>lock()</code>, we can pass another function to it
				as an argument (see
				<a
					href="https://kotlinlang.org/docs/reference/reflection.html#function-references"
				>
					function references
				</a>
				):
			</p>
			<pre><code>fun toBeSynchronized() = sharedResource.operation()

			val result = lock(lock, ::toBeSynchronized)
			</code></pre>
			<p>
				Another, often more convenient way is to pass a
				<a
					href="https://kotlinlang.org/docs/reference/lambdas.html#lambda-expressions-and-anonymous-functions"
				>
					lambda expression
				</a>
				:
			</p>
			<pre><code>val result = lock(lock, { sharedResource.operation() })
			</code></pre>
			<p>
				Lambda expressions are described in more
				<a
					href="https://kotlinlang.org/docs/reference/lambdas.html#lambda-expressions-and-anonymous-functions"
				>
					detail below
				</a>
				, but for purposes of continuing this section, let\'s see a brief overview:
			</p>
			<ul>
				<li>
					A lambda expression is always surrounded by curly braces,
				</li>
				<li>
					Its parameters (if any) are declared before <code>-&gt;</code>
					(parameter types may be omitted),
				</li>
				<li>
					The body goes after <code>-&gt;</code> (when present).
				</li>
			</ul>
			<p>
				In Kotlin, there is a convention that if the last parameter to a function
				is a function, and you\'re passing a lambda expression as the corresponding
				argument, you can specify it outside of parentheses:
			</p>
			<pre><code>lock (lock) {
				sharedResource.operation()
			}
			</code></pre>
			<p>
				Another example of a higher-order function would be <code>map()</code>:
			</p>
			<pre><code>fun &lt;T, R&gt; List&lt;T&gt;.map(transform: (T) -&gt; R): List&lt;R&gt; {
				val result = arrayListOf&lt;R&gt;()
				for (item in this)
					result.add(transform(item))
				return result
			}
			</code></pre>
			<p>
				This function can be called as follows:
			</p>
			<pre><code>val doubled = ints.map { value -&gt; value * 2 }
			</code></pre>
			<p>
				Note that the parentheses in a call can be omitted entirely if the lambda
				is the only argument to that call.
			</p>
			<h3 id="it-implicit-name-of-a-single-parameter">
				<code>it</code>
				: implicit name of a single parameter
				<a
					href="https://kotlinlang.org/docs/reference/lambdas.html#it-implicit-name-of-a-single-parameter"
				>
				</a>
			</h3>
			<p>
				One other helpful convention is that if a function literal has only one
			parameter, its declaration may be omitted (along with the    <code>-&gt;</code>), and its name will be <code>it</code>:
			</p>
			<pre><code>ints.map { it * 2 }
			</code></pre>
			<p>
				These conventions allow to write
				<a href="http://msdn.microsoft.com/en-us/library/bb308959.aspx">
					LINQ-style
				</a>
				code:
			</p>
			<pre><code>strings.filter { it.length == 5 }.sortBy { it }.map { it.toUpperCase() }
			</code></pre>
			<h3 id="underscore-for-unused-variables-since-11">
				Underscore for unused variables (since 1.1)
				<a
					href="https://kotlinlang.org/docs/reference/lambdas.html#underscore-for-unused-variables-since-11"
				>
				</a>
			</h3>
			<p>
				If the lambda parameter is unused, you can place an underscore instead of
				its name:
			</p>
			<pre><code>map.forEach { _, value -&gt; println("$value!") }
			</code></pre>
			<h3 id="destructuring-in-lambdas-since-11">
				Destructuring in Lambdas (since 1.1)
				<a
					href="https://kotlinlang.org/docs/reference/lambdas.html#destructuring-in-lambdas-since-11"
				>
				</a>
			</h3>
			<p>
				Destructuring in lambdas is described as a part of
				<a
					href="https://kotlinlang.org/docs/reference/multi-declarations.html#destructuring-in-lambdas-since-11"
				>
					destructuring declarations
				</a>
				.
			</p>
			<h2 id="inline-functions">
				Inline Functions
				<a
					href="https://kotlinlang.org/docs/reference/lambdas.html#inline-functions"
				>
				</a>
			</h2>
			<p>
				Sometimes it is beneficial to enhance performance of higher-order functions
				using
				<a href="https://kotlinlang.org/docs/reference/inline-functions.html">
					inline functions
				</a>
				.
			</p>
			<h2 id="lambda-expressions-and-anonymous-functions">
				Lambda Expressions and Anonymous Functions
				<a
					href="https://kotlinlang.org/docs/reference/lambdas.html#lambda-expressions-and-anonymous-functions"
				>
				</a>
			</h2>
			<p>
				A lambda expression or an anonymous function is a "function literal", i.e.
				a function that is not declared, but passed immediately as an expression.
				Consider the following example:
			</p>
			<pre><code>max(strings, { a, b -&gt; a.length &lt; b.length })
			</code></pre>
			<p>
				Function <code>max</code> is a higher-order function, i.e. it takes a
				function value as the second argument. This second argument is an
				expression that is itself a function, i.e. a function literal. As a
				function, it is equivalent to
			</p>
			<pre><code>fun compare(a: String, b: String): Boolean = a.length &lt; b.length
			</code></pre>
			<h3 id="function-types">
				Function Types
				<a href="https://kotlinlang.org/docs/reference/lambdas.html#function-types">
				</a>
			</h3>
			<p>
				For a function to accept another function as a parameter, we have to
				specify a function type for that parameter. For example the abovementioned
				function <code>max</code> is defined as follows:
			</p>
			<pre><code>fun &lt;T&gt; max(collection: Collection&lt;T&gt;, less: (T, T) -&gt; Boolean): T? {
				var max: T? = null
				for (it in collection)
					if (max == null || less(max, it))
						max = it
				return max
			}
			</code></pre>
			<p>
			The parameter <code>less</code> is of type    <code>(T, T) -&gt; Boolean</code>, i.e. a function that takes two
				parameters of type <code>T</code>and returns a <code>Boolean</code>: true
				if the first one is smaller than the second one.
			</p>
			<p>
				In the body, line 4, <code>less</code> is used as a function: it is called
				by passing two arguments of type <code>T</code>.
			</p>
			<p>
				A function type is written as above, or may have named parameters, if you
				want to document the meaning of each parameter.
			</p>
			<pre><code>val compare: (x: T, y: T) -&gt; Int = ...
			</code></pre>
			<h3 id="lambda-expression-syntax">
				Lambda Expression Syntax
				<a
					href="https://kotlinlang.org/docs/reference/lambdas.html#lambda-expression-syntax"
				>
				</a>
			</h3>
			<p>
				The full syntactic form of lambda expressions, i.e. literals of function
				types, is as follows:
			</p>
			<pre><code>val sum = { x: Int, y: Int -&gt; x + y }
			</code></pre>
			<p>
				A lambda expression is always surrounded by curly braces, parameter
				declarations in the full syntactic form go inside parentheses and have
				optional type annotations, the body goes after an <code>-&gt;</code> sign.
				If the inferred return type of the lambda is not <code>Unit</code>, the
				last (or possibly single) expression inside the lambda body is treated as
				the return value.
			</p>
			<p>
				If we leave all the optional annotations out, what\'s left looks like this:
			</p>
			<pre><code>val sum: (Int, Int) -&gt; Int = { x, y -&gt; x + y }
			</code></pre>
			<p>
				It\'s very common that a lambda expression has only one parameter. If Kotlin
				can figure the signature out itself, it allows us not to declare the only
			parameter, and will implicitly declare it for us under the name    <code>it</code>:
			</p>
			<pre><code>ints.filter { it &gt; 0 } // this literal is of type \'(it: Int) -&gt; Boolean\'
			</code></pre>
			<p>
				We can explicitly return a value from the lambda using the
				<a
					href="https://kotlinlang.org/docs/reference/returns.html#return-at-labels"
				>
					qualified return
				</a>
				syntax. Otherwise, the value of the last expression is implicitly returned.
				Therefore, the two following snippets are equivalent:
			</p>
			<pre><code>ints.filter {
				val shouldFilter = it &gt; 0
				shouldFilter
			}

			ints.filter {
				val shouldFilter = it &gt; 0
				return@filter shouldFilter
			}
			</code></pre>
			<p>
				Note that if a function takes another function as the last parameter, the
				lambda expression argument can be passed outside the parenthesized argument
				list. See the grammar for
				<a href="https://kotlinlang.org/docs/reference/grammar.html#callSuffix">
					callSuffix
				</a>
				.
			</p>
			<h3 id="anonymous-functions">
				Anonymous Functions
				<a
					href="https://kotlinlang.org/docs/reference/lambdas.html#anonymous-functions"
				>
				</a>
			</h3>
			<p>
				One thing missing from the lambda expression syntax presented above is the
				ability to specify the return type of the function. In most cases, this is
				unnecessary because the return type can be inferred automatically. However,
				if you do need to specify it explicitly, you can use an alternative syntax:
				an <em>anonymous function</em>.
			</p>
			<pre><code>fun(x: Int, y: Int): Int = x + y
			</code></pre>
			<p>
				An anonymous function looks very much like a regular function declaration,
				except that its name is omitted. Its body can be either an expression (as
				shown above) or a block:
			</p>
			<pre><code>fun(x: Int, y: Int): Int {
				return x + y
			}
			</code></pre>
			<p>
				The parameters and the return type are specified in the same way as for
				regular functions, except that the parameter types can be omitted if they
				can be inferred from context:
			</p>
			<pre><code>ints.filter(fun(item) = item &gt; 0)
			</code></pre>
			<p>
				The return type inference for anonymous functions works just like for
				normal functions: the return type is inferred automatically for anonymous
				functions with an expression body and has to be specified explicitly (or is
				assumed to be <code>Unit</code>) for anonymous functions with a block body.
			</p>
			<p>
				Note that anonymous function parameters are always passed inside the
				parentheses. The shorthand syntax allowing to leave the function outside
				the parentheses works only for lambda expressions.
			</p>
			<p>
				One other difference between lambda expressions and anonymous functions is
				the behavior of
				<a
					href="https://kotlinlang.org/docs/reference/inline-functions.html#non-local-returns"
				>
					non-local returns
				</a>
				. A return statement without a label always returns from the function
				declared with the funkeyword. This means that a return inside a lambda
				expression will return from the enclosing function, whereas a return inside
				an anonymous function will return from the anonymous function itself.
			</p>
			<h3 id="closures">
			Closures    <a href="https://kotlinlang.org/docs/reference/lambdas.html#closures"></a>
			</h3>
			<p>
				A lambda expression or anonymous function (as well as a
				<a
					href="https://kotlinlang.org/docs/reference/functions.html#local-functions"
				>
					local function
				</a>
				and an
				<a
					href="https://kotlinlang.org/docs/reference/object-declarations.html#object-expressions"
				>
					object expression
				</a>
				) can access its <em>closure</em>, i.e. the variables declared in the outer
				scope. Unlike Java, the variables captured in the closure can be modified:
			</p>
			<pre><code>var sum = 0
			ints.filter { it &gt; 0 }.forEach {
				sum += it
			}
			print(sum)
			</code></pre>
			<h3 id="function-literals-with-receiver">
				Function Literals with Receiver
				<a
					href="https://kotlinlang.org/docs/reference/lambdas.html#function-literals-with-receiver"
				>
				</a>
			</h3>
			<p>
			Kotlin provides the ability to call a function literal with a specified    <em>receiver object</em>. Inside the body of the function literal, you can
				call methods on that receiver object without any additional qualifiers.
				This is similar to extension functions, which allow you to access members
				of the receiver object inside the body of the function. One of the most
				important examples of their usage is
				<a href="https://kotlinlang.org/docs/reference/type-safe-builders.html">
					Type-safe Groovy-style builders
				</a>
				.
			</p>
			<p>
				The type of such a function literal is a function type with receiver:
			</p>
			<pre><code>sum : Int.(other: Int) -&gt; Int
			</code></pre>
			<p>
				The function literal can be called as if it were a method on the receiver
				object:
			</p>
			<pre><code>1.sum(2)
			</code></pre>
			<p>
				The anonymous function syntax allows you to specify the receiver type of a
				function literal directly. This can be useful if you need to declare a
				variable of a function type with receiver, and to use it later.
			</p>
			<pre><code>val sum = fun Int.(other: Int): Int = this + other
			</code></pre>
			<p>
				Lambda expressions can be used as function literals with receiver when the
				receiver type can be inferred from context.
			</p>
			<pre><code>class HTML {
				fun body() { ... }
			}

			fun html(init: HTML.() -&gt; Unit): HTML {
				val html = HTML()  // create the receiver object
				html.init()        // pass the receiver object to the lambda
				return html
			}


			html {       // lambda with receiver begins here
				body()   // calling a method on the receiver object
			}</code></pre>


		]]>
	</string>

    <string name="topicContentInlineFunctions">
		<![CDATA[

 			<h1 id="inline-functions">
				Inline Functions
				<a
					href="https://kotlinlang.org/docs/reference/inline-functions.html#inline-functions"
				>
				</a>
			</h1>
			<p>
				Using
				<a href="https://kotlinlang.org/docs/reference/lambdas.html">
					higher-order functions
				</a>
				imposes certain runtime penalties: each function is an object, and it
				captures a closure, i.e. those variables that are accessed in the body of
				the function. Memory allocations (both for function objects and classes)
				and virtual calls introduce runtime overhead.
			</p>
			<p>
				But it appears that in many cases this kind of overhead can be eliminated
				by inlining the lambda expressions. The functions shown below are good
				examples of this situation. I.e., the <code>lock()</code> function could be
				easily inlined at call-sites. Consider the following case:
			</p>
			<pre><code>lock(l) { foo() }
			</code></pre>
			<p>
				Instead of creating a function object for the parameter and generating a
				call, the compiler could emit the following code
			</p>
			<pre><code>l.lock()
			try {
				foo()
			}
			finally {
				l.unlock()
			}
			</code></pre>
			<p>
				Isn\'t it what we wanted from the very beginning?
			</p>
			<p>
				To make the compiler do this, we need to mark the <code>lock()</code>
				function with the <code>inline</code> modifier:
			</p>
			<pre><code>inline fun lock&lt;T&gt;(lock: Lock, body: () -&gt; T): T {
				// ...
			}
			</code></pre>
			<p>
				The <code>inline</code> modifier affects both the function itself and the
				lambdas passed to it: all of those will be inlined into the call site.
			</p>
			<p>
				Inlining may cause the generated code to grow, but if we do it in a
				reasonable way (do not inline big functions) it will pay off in
				performance, especially at "megamorphic" call-sites inside loops.
			</p>
			<h2 id="noinline">
				noinline
				<a
					href="https://kotlinlang.org/docs/reference/inline-functions.html#noinline"
				>
				</a>
			</h2>
			<p>
				In case you want only some of the lambdas passed to an inline function to
			be inlined, you can mark some of your function parameters with the    <code>noinline</code> modifier:
			</p>
			<pre><code>inline fun foo(inlined: () -&gt; Unit, noinline notInlined: () -&gt; Unit) {
				// ...
			}
			</code></pre>
			<p>
				Inlinable lambdas can only be called inside the inline functions or passed
				as inlinable arguments, but <code>noinline</code> ones can be manipulated
				in any way we like: stored in fields, passed around etc.
			</p>
			<p>
				Note that if an inline function has no inlinable function parameters and no
				<a
					href="https://kotlinlang.org/docs/reference/inline-functions.html#reified-type-parameters"
				>
					reified type parameters
				</a>
				, the compiler will issue a warning, since inlining such functions is very
				unlikely to be beneficial (you can suppress the warning if you are sure the
				inlining is needed).
			</p>
			<h2 id="non-local-returns">
				Non-local returns
				<a
					href="https://kotlinlang.org/docs/reference/inline-functions.html#non-local-returns"
				>
				</a>
			</h2>
			<p>
				In Kotlin, we can only use a normal, unqualified <code>return</code> to
				exit a named function or an anonymous function. This means that to exit a
				lambda, we have to use a
				<a
					href="https://kotlinlang.org/docs/reference/returns.html#return-at-labels"
				>
					label
				</a>
				, and a bare <code>return</code> is forbidden inside a lambda, because a
				lambda can not make the enclosing function return:
			</p>
			<pre><code>fun foo() {
				ordinaryFunction {
					return // ERROR: can not make `foo` return here
				}
			}
			</code></pre>
			<p>
				But if the function the lambda is passed to is inlined, the return can be
				inlined as well, so it is allowed:
			</p>
			<pre><code>fun foo() {
				inlineFunction {
					return // OK: the lambda is inlined
				}
			}
			</code></pre>
			<p>
				Such returns (located in a lambda, but exiting the enclosing function) are
				called <em>non-local</em> returns. We are used to this sort of constructs
				in loops, which inline functions often enclose:
			</p>
			<pre><code>fun hasZeros(ints: List&lt;Int&gt;): Boolean {
				ints.forEach {
					if (it == 0) return true // returns from hasZeros
				}
				return false
			}
			</code></pre>
			<p>
				Note that some inline functions may call the lambdas passed to them as
				parameters not directly from the function body, but from another execution
				context, such as a local object or a nested function. In such cases,
				non-local control flow is also not allowed in the lambdas. To indicate
			that, the lambda parameter needs to be marked with the    <code>crossinline</code> modifier:
			</p>
			<pre><code>inline fun f(crossinline body: () -&gt; Unit) {
				val f = object: Runnable {
					override fun run() = body()
				}
				// ...
			}
			</code></pre>
			<blockquote>
				<p>
					<code>break</code>
					and <code>continue</code> are not yet available in inlined lambdas, but
					we are planning to support them too
				</p>
			</blockquote>
			<h2 id="reified-type-parameters">
				Reified type parameters
				<a
					href="https://kotlinlang.org/docs/reference/inline-functions.html#reified-type-parameters"
				>
				</a>
			</h2>
			<p>
				Sometimes we need to access a type passed to us as a parameter:
			</p>
			<pre><code>fun &lt;T&gt; TreeNode.findParentOfType(clazz: Class&lt;T&gt;): T? {
				var p = parent
				while (p != null &amp;&amp; !clazz.isInstance(p)) {
					p = p.parent
				}
				@Suppress("UNCHECKED_CAST")
				return p as T?
			}
			</code></pre>
			<p>
				Here, we walk up a tree and use reflection to check if a node has a certain
				type. It’s all fine, but the call site is not very pretty:
			</p>
			<pre><code>treeNode.findParentOfType(MyTreeNode::class.java)
			</code></pre>
			<p>
				What we actually want is simply pass a type to this function, i.e. call it
				like this:
			</p>
			<pre><code>treeNode.findParentOfType&lt;MyTreeNode&gt;()
			</code></pre>
			<p>
				To enable this, inline functions support <em>reified type parameters</em>,
				so we can write something like this:
			</p>
			<pre><code>inline fun &lt;reified T&gt; TreeNode.findParentOfType(): T? {
				var p = parent
				while (p != null &amp;&amp; p !is T) {
					p = p.parent
				}
				return p as T?
			}
			</code></pre>
			<p>
				We qualified the type parameter with the <code>reified</code> modifier, now
				it’s accessible inside the function, almost as if it were a normal class.
				Since the function is inlined, no reflection is needed, normal operators
				like <code>!is</code>and <code>as</code> are working now. Also, we can call
			it as mentioned above:    <code>myTree.findParentOfType&lt;MyTreeNodeType&gt;()</code>.
			</p>
			<p>
				Though reflection may not be needed in many cases, we can still use it with
				a reified type parameter:
			</p>
			<pre><code>inline fun &lt;reified T&gt; membersOf() = T::class.members

			fun main(s: Array&lt;String&gt;) {
				println(membersOf&lt;StringBuilder&gt;().joinToString("\n"))
			}
			</code></pre>
			<p>
				Normal functions (not marked as inline) can not have reified parameters. A
				type that does not have a run-time representation (e.g. a non-reified type
				parameter or a fictitious type like <code>Nothing</code>) can not be used
				as an argument for a reified type parameter.
			</p>
			<p>
				For a low-level description, see the
				<a
					href="https://github.com/JetBrains/kotlin/blob/master/spec-docs/reified-type-parameters.md"
				>
					spec document
				</a>
				.
			</p>
			<h2 id="inline-properties-since-11">
				Inline properties (since 1.1)
				<a
					href="https://kotlinlang.org/docs/reference/inline-functions.html#inline-properties-since-11"
				>
				</a>
			</h2>
			<p>
				The <code>inline</code> modifier can be used on accessors of properties
				that don\'t have a backing field. You can annotate individual property
				accessors:
			</p>
			<pre><code>val foo: Foo
				inline get() = Foo()

			var bar: Bar
				get() = ...
				inline set(v) { ... }
			</code></pre>
			<p>
				You can also annotate an entire property, which marks both of its accessors
				as inline:
			</p>
			<pre><code>inline var bar: Bar
				get() = ...
				set(v) { ... }
			</code></pre>
			<p>
				At the call site, inline accessors are inlined as regular inline functions.
			</p>


		]]>
	</string>

    <string name="topicContentCoroutines">
		<![CDATA[

 			<h1 id="coroutines">
				Coroutines
				<a href="https://kotlinlang.org/docs/reference/coroutines.html#coroutines">
				</a>
			</h1>
			<h1 id="coroutines">
				<blockquote>
					<p>
						Coroutines are <em>experimental</em> in Kotlin 1.1. See details
						<a
							href="https://kotlinlang.org/docs/reference/coroutines.html#experimental-status-of-coroutines"
						>
							below
						</a>
					</p>
				</blockquote>
			</h1>
			<p>
				Some APIs initiate long-running operations (such as network IO, file IO,
				CPU- or GPU-intensive work, etc) and require the caller to block until they
				complete. Coroutines provide a way to avoid blocking a thread and replace
				it with a cheaper and more controllable operation: <em>suspension</em> of a
				coroutine.
			</p>
			<p>
				Coroutines simplify asynchronous programming by putting the complications
			into libraries. The logic of the program can be expressed    <em>sequentially</em> in a coroutine, and the underlying library will
				figure out the asynchrony for us. The library can wrap relevant parts of
				the user code into callbacks, subscribe to relevant events, schedule
				execution on different threads (or even different machines!), and the code
				remains as simple as if it was sequentially executed.
			</p>
			<p>
				Many asynchronous mechanisms available in other languages can be
				implemented as libraries using Kotlin coroutines. This includes
				<a
					href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/coroutines-guide.md#composing-suspending-functions"
				>
					<code>async</code>
					/<code>await</code>
				</a>
				from C# and ECMAScript,
				<a
					href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/coroutines-guide.md#channels"
				>
					channels
				</a>
				and
				<a
					href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/coroutines-guide.md#select-expression"
				>
					<code>select</code>
				</a>
				from Go, and
				<a
					href="https://kotlinlang.org/docs/reference/coroutines.html#generators-api-in-kotlincoroutines"
				>
					generators/<code>yield</code>
				</a>
				from C# and Python. See the description
				<a
					href="https://kotlinlang.org/docs/reference/coroutines.html#standard-apis"
				>
					below
				</a>
				for libraries providing such constructs.
			</p>
			<h2 id="blocking-vs-suspending">
				Blocking vs Suspending
				<a
					href="https://kotlinlang.org/docs/reference/coroutines.html#blocking-vs-suspending"
				>
				</a>
			</h2>
			<h1>
			</h1>
			<p>
				Basically, coroutines are computations that can be <em>suspended</em>
				without <em>blocking a thread</em>. Blocking threads is often expensive,
				especially under high load, because only a relatively small number of
				threads is practical to keep around, so blocking one of them leads to some
				important work being delayed.
			</p>
			<p>
				Coroutine suspension is almost free, on the other hand. No context switch
				or any other involvement of the OS is required. And on top of that,
				suspension can be controlled by a user library to a large extent: as
				library authors, we can decide what happens upon a suspension and
				optimize/log/intercept according to our needs.
			</p>
			<p>
				Another difference is that coroutines can not be suspended at random
				instructions, but rather only at so called <em>suspension points</em>,
				which are calls to specially marked functions.
			</p>
			<h2 id="suspending-functions">
				Suspending functions
				<a
					href="https://kotlinlang.org/docs/reference/coroutines.html#suspending-functions"
				>
				</a>
			</h2>
			<h1>
			</h1>
			<p>
				A suspension happens when we call a function marked with the special
				modifier, <code>suspend</code>:
			</p>
			<pre><code>suspend fun doSomething(foo: Foo): Bar {
				...
			}
			</code></pre>
			<p>
				Such functions are called <em>suspending functions</em>, because calls to
				them may suspend a coroutine (the library can decide to proceed without
				suspension, if the result for the call in question is already available).
				Suspending functions can take parameters and return values in the same
				manner as regular functions, but they can only be called from coroutines
				and other suspending functions. In fact, to start a coroutine, there must
				be at least one suspending function, and it is usually anonymous (i.e. it
			is a suspending lambda). Let\'s look at an example, a simplified    <code>async()</code> function (from the
				<a
					href="https://kotlinlang.org/docs/reference/coroutines.html#generators-api-in-kotlincoroutines"
				>
					<code>kotlinx.coroutines</code>
				</a>
				library):
			</p>
			<pre><code>fun &lt;T&gt; async(block: suspend () -&gt; T)
			</code></pre>
			<p>
				Here, <code>async()</code> is a regular function (not a suspending
				function), but the <code>block</code> parameter has a function type with
				the <code>suspend</code> modifier: <code>suspend () -&gt; T</code>. So,
			when we pass a lambda to <code>async()</code>, it is a    <em>suspending lambda</em>, and we can call a suspending function from it:
			</p>
			<pre><code>async {
				doSomething(foo)
				...
			}
			</code></pre>
			<p>
				To continue the analogy, <code>await()</code> can be a suspending function
				(hence also callable from within an <code>async {}</code> block) that
				suspends a coroutine until some computation is done and returns its result:
			</p>
			<pre><code>async {
				...
				val result = computation.await()
				...
			}
			</code></pre>
			<p>
			More information on how actual <code>async/await</code> functions work in    <code>kotlinx.coroutines</code> can be found
				<a
					href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/coroutines-guide.md#composing-suspending-functions"
				>
					here
				</a>
				.
			</p>
			<p>
			Note that suspending functions <code>await()</code> and<code>doSomething()</code> can not be called from a regular function like    <code>main()</code>:
			</p>
			<pre><code>fun main(args: Array&lt;String&gt;) {
				doSomething() // ERROR: Suspending function called from a non-coroutine context
			}
			</code></pre>
			<p>
				Also note that suspending functions can be virtual, and when overriding
				them, the <code>suspend</code> modifier has to be specified:
			</p>
			<pre><code>interface Base {
				suspend fun foo()
			}

			class Derived: Base {
				override suspend fun foo() { ... }
			}
			</code></pre>
			<h3 id="restrictssuspension-annotation">
				<code>@RestrictsSuspension</code>
				annotation
				<a
					href="https://kotlinlang.org/docs/reference/coroutines.html#restrictssuspension-annotation"
				>
				</a>
			</h3>
			<h1>
			</h1>
			<p>
				Extension functions (and lambdas) can also be marked <code>suspend</code>,
				just like regular ones. This enables creation of
				<a href="https://kotlinlang.org/docs/reference/type-safe-builders.html">
					DSLs
				</a>
				and other APIs that users can extend. In some cases the library author
				needs to prevent the user from adding <em>new ways</em> of suspending a
				coroutine.
			</p>
			<p>
				To achieve this, the
				<a
					href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines.experimental/-restricts-suspension/index.html"
				>
					<code>@RestrictsSuspension</code>
				</a>
				annotation may be used. When a receiver class or interface <code>R</code>is
				annotated with it, all suspending extensions are required to delegate to
				either members of <code>R</code> or other extensions to it. Since
				extensions can\'t delegate to each other indefinitely (the program would not
				terminate), this guarantees that all suspensions happen through calling
				members of <code>R</code> that the author of the library can fully control.
			</p>
			<p>
				This is relevant in the <em>rare</em> cases when every suspension is
				handled in a special way in the library. For example, when implementing
				generators through the
				<a
					href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines.experimental/build-sequence.html"
				>
					<code>buildSequence()</code>
				</a>
				function described
				<a
					href="https://kotlinlang.org/docs/reference/coroutines.html#generators-api-in-kotlincoroutines"
				>
					below
				</a>
				, we need to make sure that any suspending call in the coroutine ends up
				calling either <code>yield()</code> or <code>yieldAll()</code>and not any
				other function. This is why
				<a
					href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines.experimental/-sequence-builder/index.html"
				>
					<code>SequenceBuilder</code>
				</a>
				is annotated with <code>@RestrictsSuspension</code>:
			</p>
			<pre><code>@RestrictsSuspension
			public abstract class SequenceBuilder&lt;in T&gt; {
				...
			}
			</code></pre>
			<p>
				See the sources
				<a
					href="https://github.com/JetBrains/kotlin/blob/master/libraries/stdlib/src/kotlin/coroutines/experimental/SequenceBuilder.kt"
				>
					on Github
				</a>
				.
			</p>
			<h2 id="the-inner-workings-of-coroutines">
				The inner workings of coroutines
				<a
					href="https://kotlinlang.org/docs/reference/coroutines.html#the-inner-workings-of-coroutines"
				>
				</a>
			</h2>
			<h1>
			</h1>
			<p>
				We are not trying here to give a complete explanation of how coroutines
				work under the hood, but a rough sense of what\'s going on is rather
				important.
			</p>
			<p>
				Coroutines are completely implemented through a compilation technique (no
				support from the VM or OS side is required), and suspension works through
				code transformation. Basically, every suspending function (optimizations
				may apply, but we\'ll not go into this here) is transformed to a state
				machine where states correspond to suspending calls. Right before a
				suspension, the next state is stored in a field of a compiler-generated
				class along with relevant local variables, etc. Upon resumption of that
				coroutine, local variables are restored and the state machine proceeds from
				the state right after suspension.
			</p>
			<p>
				A suspended coroutine can be stored and passed around as an object that
			keeps its suspended state and locals. The type of such objects is    <code>Continuation</code>, and the overall code transformation described
				here corresponds to the classical
				<a href="https://en.wikipedia.org/wiki/Continuation-passing_style">
					Continuation-passing style
				</a>
			. Consequently, suspending functions take an extra parameter of type    <code>Continuation</code> under the hood.
			</p>
			<p>
				More details on how coroutines work may be found in
				<a
					href="https://github.com/Kotlin/kotlin-coroutines/blob/master/kotlin-coroutines-informal.md"
				>
					this design document
				</a>
				. Similar descriptions of async/await in other languages (such as C# or
				ECMAScript 2016) are relevant here, although the language features they
				implement may not be as general as Kotlin coroutines.
			</p>
			<h2 id="experimental-status-of-coroutines">
				Experimental status of coroutines
				<a
					href="https://kotlinlang.org/docs/reference/coroutines.html#experimental-status-of-coroutines"
				>
				</a>
			</h2>
			<h1>
			</h1>
			<p>
				The design of coroutines is
				<a
					href="https://kotlinlang.org/docs/reference/compatibility.html#experimental-features"
				>
					experimental
				</a>
				, which means that it may be changed in the upcoming releases. When
			compiling coroutines in Kotlin 1.1, a warning is reported by default:    <em>The feature "coroutines" is experimental</em>. To remove the warning,
				you need to specify an
				<a
					href="https://kotlinlang.org/docs/diagnostics/experimental-coroutines.html"
				>
					opt-in flag
				</a>
				.
			</p>
			<p>
				Due to its experimental status, the coroutine-related API in the Standard
				Library is put under the <code>kotlin.coroutines.experimental</code>
				package. When the design is finalized and the experimental status lifted,
				the final API will be moved to <code>kotlin.coroutines</code>, and the
				experimental package will be kept around (probably in a separate artifact)
				for backward compatibility.
			</p>
			<p>
				IMPORTANT NOTE: We advise library authors to follow the same convention:
				add the "experimental" (e.g. <code>com.example.experimental</code>) suffix
				to your packages exposing coroutine-based APIs so that your library remains
				binary compatible. When the final API is released, follow these steps:
			</p>
			<ul>
				<li>
					copy all the APIs to <code>com.example</code> (without the experimental
					suffix),
				</li>
				<li>
					keep the experimental package around for backward compatibility.
				</li>
			</ul>
			<p>
				This will minimize migration issues for your users.
			</p>
			<h2 id="standard-apis">
				Standard APIs
				<a
					href="https://kotlinlang.org/docs/reference/coroutines.html#standard-apis"
				>
				</a>
			</h2>
			<h1>
			</h1>
			<p>
				Coroutines come in three main ingredients:
			</p>
			<ul>
				<li>
					language support (i.s. suspending functions, as described above),
				</li>
				<li>
					low-level core API in the Kotlin Standard Library,
				</li>
				<li>
					high-level APIs that can be used directly in the user code.
				</li>
			</ul>
			<h3 id="low-level-api-kotlincoroutines">
				Low-level API: <code>kotlin.coroutines</code>
				<a
					href="https://kotlinlang.org/docs/reference/coroutines.html#low-level-api-kotlincoroutines"
				>
				</a>
			</h3>
			<h1>
			</h1>
			<p>
				Low-level API is relatively small and should never be used other than for
				creating higher-level libraries. It consists of two main packages:
			</p>
			<ul>
				<li>
					<a
						href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines.experimental/index.html"
					>
						<code>kotlin.coroutines.experimental</code>
					</a>
					with main types and primitives such as
					<ul>
						<li>
							<a
								href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines.experimental/create-coroutine.html"
							>
								<code>createCoroutine()</code>
							</a>
						</li>
						<li>
							<a
								href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines.experimental/start-coroutine.html"
							>
								<code>startCoroutine()</code>
							</a>
						</li>
						<li>
							<a
								href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines.experimental/suspend-coroutine.html"
							>
								<code>suspendCoroutine()</code>
							</a>
						</li>
					</ul>
				</li>
				<li>
					<a
						href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines.experimental.intrinsics/index.html"
					>
						<code>kotlin.coroutines.experimental.intrinsics</code>
					</a>
					with even lower-level intrinsics such as
					<a
						href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines.experimental.intrinsics/suspend-coroutine-or-return.html"
					>
						<code>suspendCoroutineOrReturn</code>
					</a>
				</li>
			</ul>
			<p>
				More details about the usage of these APIs can be found
				<a
					href="https://github.com/Kotlin/kotlin-coroutines/blob/master/kotlin-coroutines-informal.md"
				>
					here
				</a>
				.
			</p>
			<h3 id="generators-api-in-kotlincoroutines">
				Generators API in <code>kotlin.coroutines</code>
				<a
					href="https://kotlinlang.org/docs/reference/coroutines.html#generators-api-in-kotlincoroutines"
				>
				</a>
			</h3>
			<h1>
			</h1>
			<p>
			The only "application-level" functions in    <code>kotlin.coroutines.experimental</code> are
			</p>
			<ul>
				<li>
					<a
						href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines.experimental/build-sequence.html"
					>
						<code>buildSequence()</code>
					</a>
				</li>
				<li>
					<a
						href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines.experimental/build-iterator.html"
					>
						<code>buildIterator()</code>
					</a>
				</li>
			</ul>
			<p>
				These are shipped within <code>kotlin-stdlib</code> because they are
				related to sequences. In fact, these functions (and we can limit ourselves
				to <code>buildSequence()</code> alone here) implement <em>generators</em>,
				i.e. provide a way to cheaply build a lazy sequence:
			</p>
			<div>
				<div>
					<div>
						<div>
							<div>
							</div>
							<div>
							</div>
							<div>
							</div>
							<div>
								<div>
								</div>
								<div tabindex="-1">
									<div>
										<div>
											<div>
												<div>
													<div>
														<div>
															<div>
															</div>
														</div>
													</div>
													<div>
													</div>
													<div>
													</div>
													<div>
														<div>
														</div>
													</div>
													<div>
														<div>
															<div>
															</div>
															<div>
																<div>
																	1
																</div>
															</div>
															<pre>import kotlin.coroutines.experimental.*</pre>
														</div>
														<div>
															<div>
															</div>
															<div>
																<div>
																	2
																</div>
															</div>
															<pre>​</pre>
														</div>
														<div>
															<div>
															</div>
															<div>
																<div>
																	3
																</div>
															</div>
															<pre>fun main(args: Array&lt;String&gt;) {</pre>
														</div>
														<div>
															<div>
																<div>
																	4
																</div>
															</div>
															<pre>    val fibonacciSeq = buildSequence {</pre>
														</div>
														<div>
															<div>
																<div>
																	5
																</div>
															</div>
															<pre>        var a = 0</pre>
														</div>
														<div>
															<div>
																<div>
																	6
																</div>
															</div>
															<pre>        var b = 1</pre>
														</div>
														<div>
															<div>
																<div>
																	7
																</div>
															</div>
															<pre>​</pre>
														</div>
														<div>
															<div>
																<div>
																	8
																</div>
															</div>
															<pre>        yield(1)</pre>
														</div>
														<div>
															<div>
																<div>
																	9
																</div>
															</div>
															<pre>​</pre>
														</div>
														<div>
															<div>
																<div>
																	10
																</div>
															</div>
															<pre>        while (true) {</pre>
														</div>
														<div>
															<div>
																<div>
																	11
																</div>
															</div>
															<pre>            yield(a + b)</pre>
														</div>
														<div>
															<div>
																<div>
																	12
																</div>
															</div>
															<pre>​</pre>
														</div>
														<div>
															<div>
																<div>
																	13
																</div>
															</div>
															<pre>            val tmp = a + b</pre>
														</div>
														<div>
															<div>
																<div>
																	14
																</div>
															</div>
															<pre>            a = b</pre>
														</div>
														<div>
															<div>
																<div>
																	15
																</div>
															</div>
															<pre>            b = tmp</pre>
														</div>
														<div>
															<div>
																<div>
																	16
																</div>
															</div>
															<pre>        }</pre>
														</div>
														<div>
															<div>
																<div>
																	17
																</div>
															</div>
															<pre>    }</pre>
														</div>
														<div>
															<div>
															</div>
															<div>
																<div>
																	18
																</div>
															</div>
															<pre>​</pre>
														</div>
														<div>
															<div>
															</div>
															<div>
																<div>
																	19
																</div>
															</div>
															<pre>    // Print the first five Fibonacci numbers</pre>
														</div>
														<div>
															<div>
															</div>
															<div>
																<div>
																	20
																</div>
															</div>
															<pre>    println(fibonacciSeq.take(8).toList())</pre>
														</div>
														<div>
															<div>
															</div>
															<div>
																<div>
																	21
																</div>
															</div>
															<pre>}</pre>
														</div>
													</div>
												</div>
											</div>
										</div>
									</div>
									<div>
									</div>
									<div>
										<div>
										</div>
										<div>
										</div>
										<div>
										</div>
									</div>
								</div>
							</div>
							<div>
							</div>
						</div>
					</div>
					<div>
						Target platform: JVMRunning on kotlin v. 1.1.3
					</div>
				</div>
			</div>
			<p>
				This generates a lazy, potentially infinite Fibonacci sequence by creating
			a coroutine that yields consecutive Fibonacci numbers by calling the    <code>yield()</code> function. When iterating over such a sequence every
				step of the iterator executes another portion of the coroutine that
				generates the next number. So, we can take any finite list of numbers out
				of this sequence, e.g. <code>fibonacciSeq.take(8).toList()</code> results
				in <code>[1, 1, 2, 3, 5, 8, 13, 21]</code>. And coroutines are cheap enough
				to make this practical.
			</p>
			<p>
				To demonstrate the real laziness of such a sequence, let\'s print some debug
				output inside a call to <code>buildSequence()</code>:
			</p>
			<div>
				<div>
					<div>
						<div>
							<div>
							</div>
							<div>
							</div>
							<div>
							</div>
							<div>
								<div>
								</div>
								<div tabindex="-1">
									<div>
										<div>
											<div>
												<div>
													<div>
														<div>
															<div>
															</div>
														</div>
													</div>
													<div>
													</div>
													<div>
													</div>
													<div>
														<div>
														</div>
													</div>
													<div>
														<div>
															<div>
															</div>
															<div>
																<div>
																	1
																</div>
															</div>
															<pre>import kotlin.coroutines.experimental.*</pre>
														</div>
														<div>
															<div>
															</div>
															<div>
																<div>
																	2
																</div>
															</div>
															<pre>​</pre>
														</div>
														<div>
															<div>
															</div>
															<div>
																<div>
																	3
																</div>
															</div>
															<pre>fun main(args: Array&lt;String&gt;) {</pre>
														</div>
														<div>
															<div>
																<div>
																	4
																</div>
															</div>
															<pre>    val lazySeq = buildSequence {</pre>
														</div>
														<div>
															<div>
																<div>
																	5
																</div>
															</div>
															<pre>        print("START ")</pre>
														</div>
														<div>
															<div>
																<div>
																	6
																</div>
															</div>
															<pre>        for (i in 1..5) {</pre>
														</div>
														<div>
															<div>
																<div>
																	7
																</div>
															</div>
															<pre>            yield(i)</pre>
														</div>
														<div>
															<div>
																<div>
																	8
																</div>
															</div>
															<pre>            print("STEP ")</pre>
														</div>
														<div>
															<div>
																<div>
																	9
																</div>
															</div>
															<pre>        }</pre>
														</div>
														<div>
															<div>
																<div>
																	10
																</div>
															</div>
															<pre>        print("END")</pre>
														</div>
														<div>
															<div>
																<div>
																	11
																</div>
															</div>
															<pre>    }</pre>
														</div>
														<div>
															<div>
																<div>
																	12
																</div>
															</div>
															<pre>​</pre>
														</div>
														<div>
															<div>
																<div>
																	13
																</div>
															</div>
															<pre>    // Print the first three elements of the sequence</pre>
														</div>
														<div>
															<div>
																<div>
																	14
																</div>
															</div>
															<pre>    lazySeq.take(3).forEach { print("$it ") }</pre>
														</div>
														<div>
															<div>
															</div>
															<div>
																<div>
																	15
																</div>
															</div>
															<pre>}</pre>
														</div>
													</div>
												</div>
											</div>
										</div>
									</div>
									<div>
									</div>
									<div>
										<div>
										</div>
										<div>
										</div>
										<div>
										</div>
									</div>
								</div>
							</div>
							<div>
							</div>
						</div>
					</div>
					<div>
						Target platform: JVMRunning on kotlin v. 1.1.3
					</div>
				</div>
			</div>
			<p>
				Run the code above to see that if we print the first three elements, the
				numbers are interleaved with the <code>STEP</code>s the generating loop.
				This means that the computation is lazy indeed. To print <code>1</code> we
			only execute until the first <code>yield(i)</code>, and print    <code>START</code> along the way. Then, to print <code>2</code> we need to
			proceed to the next <code>yield(i)</code>, and this prints    <code>STEP</code>. Same for <code>3</code>. And the next <code>STEP</code>
				never gets printed (as well as <code>END</code>), because we never
				requested further elements of the sequence.
			</p>
			<p>
			To yield a collection (or sequence) of values at once, the    <code>yieldAll()</code> function is available:
			</p>
			<div>
				<div>
					<div>
						<div>
							<div>
							</div>
							<div>
							</div>
							<div>
							</div>
							<div>
								<div>
								</div>
								<div tabindex="-1">
									<div>
										<div>
											<div>
												<div>
													<div>
														<div>
															<div>
															</div>
														</div>
														<div>
															<div>
															</div>
														</div>
													</div>
													<div>
													</div>
													<div>
													</div>
													<div>
														<div>
														</div>
													</div>
													<div>
														<div>
															<div>
															</div>
															<div>
																<div>
																	1
																</div>
															</div>
															<pre>import kotlin.coroutines.experimental.*</pre>
														</div>
														<div>
															<div>
															</div>
															<div>
																<div>
																	2
																</div>
															</div>
															<pre>​</pre>
														</div>
														<div>
															<div>
															</div>
															<div>
																<div>
																	3
																</div>
															</div>
															<pre>fun main(args: Array&lt;String&gt;) {</pre>
														</div>
														<div>
															<div>
																<div>
																	4
																</div>
															</div>
															<pre>    val lazySeq = buildSequence {</pre>
														</div>
														<div>
															<div>
																<div>
																	5
																</div>
															</div>
															<pre>        yield(0)</pre>
														</div>
														<div>
															<div>
																<div>
																	6
																</div>
															</div>
															<pre>        yieldAll(1..10) </pre>
														</div>
														<div>
															<div>
																<div>
																	7
																</div>
															</div>
															<pre>    }</pre>
														</div>
														<div>
															<div>
																<div>
																	8
																</div>
															</div>
															<pre>​</pre>
														</div>
														<div>
															<div>
																<div>
																	9
																</div>
															</div>
															<pre>    lazySeq.forEach { print("$it ") }</pre>
														</div>
														<div>
															<div>
															</div>
															<div>
																<div>
																	10
																</div>
															</div>
															<pre>}</pre>
														</div>
													</div>
												</div>
											</div>
										</div>
									</div>
									<div>
									</div>
									<div>
										<div>
										</div>
										<div>
										</div>
										<div>
										</div>
									</div>
								</div>
							</div>
							<div>
							</div>
						</div>
					</div>
					<div>
						Target platform: JVMRunning on kotlin v. 1.1.3
					</div>
				</div>
			</div>
			<p>
			The <code>buildIterator()</code> works similarly to    <code>buildSequence()</code>, but returns a lazy iterator.
			</p>
			<p>
				One can add custom yielding logic to <code>buildSequence()</code> by
				writing suspending extensions to the <code>SequenceBuilder</code> class
				(that bears the <code>@RestrictsSuspension</code> annotation described
				<a
					href="https://kotlinlang.org/docs/reference/coroutines.html#restrictssuspension-annotation"
				>
					above
				</a>
				):
			</p>
			<div>
				<div>
					<div>
						<div>
							<div>
							</div>
							<div>
							</div>
							<div>
							</div>
							<div>
								<div>
								</div>
								<div tabindex="-1">
									<div>
										<div>
											<div>
												<div>
													<div>
														<div>
															<div>
															</div>
														</div>
														<div>
															<div>
															</div>
														</div>
													</div>
													<div>
													</div>
													<div>
													</div>
													<div>
														<div>
														</div>
													</div>
													<div>
														<div>
															<div>
															</div>
															<div>
																<div>
																	1
																</div>
															</div>
															<pre>import kotlin.coroutines.experimental.*</pre>
														</div>
														<div>
															<div>
															</div>
															<div>
																<div>
																	2
																</div>
															</div>
															<pre>​</pre>
														</div>
														<div>
															<div>
																<div>
																	3
																</div>
															</div>
															<pre>suspend fun SequenceBuilder&lt;Int&gt;.yieldIfOdd(x: Int) {</pre>
														</div>
														<div>
															<div>
																<div>
																	4
																</div>
															</div>
															<pre>    if (x % 2 != 0) yield(x)</pre>
														</div>
														<div>
															<div>
																<div>
																	5
																</div>
															</div>
															<pre>}</pre>
														</div>
														<div>
															<div>
																<div>
																	6
																</div>
															</div>
															<pre>​</pre>
														</div>
														<div>
															<div>
																<div>
																	7
																</div>
															</div>
															<pre>val lazySeq = buildSequence {</pre>
														</div>
														<div>
															<div>
																<div>
																	8
																</div>
															</div>
															<pre>    for (i in 1..10) yieldIfOdd(i)</pre>
														</div>
														<div>
															<div>
																<div>
																	9
																</div>
															</div>
															<pre>}</pre>
														</div>
														<div>
															<div>
															</div>
															<div>
																<div>
																	10
																</div>
															</div>
															<pre>​</pre>
														</div>
														<div>
															<div>
															</div>
															<div>
																<div>
																	11
																</div>
															</div>
															<pre>fun main(args: Array&lt;String&gt;) {</pre>
														</div>
														<div>
															<div>
															</div>
															<div>
																<div>
																	12
																</div>
															</div>
															<pre>    lazySeq.forEach { print("$it ") }</pre>
														</div>
														<div>
															<div>
															</div>
															<div>
																<div>
																	13
																</div>
															</div>
															<pre>}</pre>
														</div>
													</div>
												</div>
											</div>
										</div>
									</div>
									<div>
									</div>
									<div>
										<div>
										</div>
										<div>
										</div>
										<div>
										</div>
									</div>
								</div>
							</div>
							<div>
							</div>
						</div>
					</div>
					<div>
						Target platform: JVMRunning on kotlin v. 1.1.3
					</div>
				</div>
			</div>
			<h3 id="other-high-level-apis-kotlinxcoroutines">
				Other high-level APIs: <code>kotlinx.coroutines</code>
				<a
					href="https://kotlinlang.org/docs/reference/coroutines.html#other-high-level-apis-kotlinxcoroutines"
				>
				</a>
			</h3>
			<h1>
			</h1>
			<p>
				Only core APIs related to coroutines are available from the Kotlin Standard
				Library. This mostly consists of core primitives and interfaces that all
				coroutine-based libraries are likely to use.
			</p>
			<p>
				Most application-level APIs based on coroutines are released as a separate
				library:
				<a href="https://github.com/Kotlin/kotlinx.coroutines">
					<code>kotlinx.coroutines</code>
				</a>
				. This library covers
			</p>
			<ul>
				<li>
			Platform-agnostic asynchronous programming with        <code>kotlinx-coroutines-core</code>
					<ul>
						<li>
			this module includes Go-like channels that support                <code>select</code> and other convenient primitives
						</li>
						<li>
							a comprehensive guide to this library is available
							<a
								href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/coroutines-guide.md"
							>
								here
							</a>
							.
						</li>
					</ul>
				</li>
				<li>
			APIs based on <code>CompletableFuture</code> from JDK 8:        <code>kotlinx-coroutines-jdk8</code>
				</li>
				<li>
			Non-blocking IO (NIO) based on APIs from JDK 7 and higher:        <code>kotlinx-coroutines-nio</code>
				</li>
				<li>
			Support for Swing (<code>kotlinx-coroutines-swing</code>) and JavaFx (        <code>kotlinx-coroutines-javafx</code>)
				</li>
				<li>
					Support for RxJava: <code>kotlinx-coroutines-rx</code>
				</li>
			</ul>
			<p>
				These libraries serve as both convenient APIs that make common tasks easy
				and end-to-end examples of how to build coroutine-based libraries.
			</p>


		]]>
	</string>

</resources>
